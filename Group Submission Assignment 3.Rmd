---
title: "Assignment 3 File"
author: "Group 15: Jordan Thompson, Arabela Tan, Zhipeng Ren"
date: "2024-11-05"
output: pdf_document
---
Setting working directory
```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/Users/arabelatan/Desktop/[1] UBC/[3] Third Year/[1] First Term/BMEG 310/[3] Group Projects/Assignment 3")
```

## Q1: Why areas of the genome with high GC content are hard to sequence?

Areas in the genome with high G-C content are challenging to sequence because they have strong hydrogen bonds. These hydrogen bonds are stable, and therefore can form secondary structures. These structures do not respond to amplification, and therefore areas with high G-C content are challenging to accurately amplify. 

## Q2
```{r}
#Function that assigns what point to be used depending if the letters match or not
verdict <- function(first_letter, second_letter){
  
  #Mismatch Score
  if(first_letter==second_letter){
    point <- 1
  }else{
    if((first_letter=="A" || first_letter=="G") && (second_letter=="G" || second_letter=="A")){
    point <- - 1
    }else if((first_letter=="T" || first_letter=="C") && (second_letter=="C" || second_letter=="T")){
    point <- -1 
    }
    else{
    point <- -5 
    }
  }
  return (point)
}

#Scoring Matrix 
#strsplit("ATTCGAC", split="")
sequence1 <- c("A","T","T","C","G","A","C")
sequence2 <- c("A","T","C","A","C")

# scoring_matrix
Needleman_Wunsch_Algorithmn <- function(first_sequence,second_sequence){
  
  #Separating the string into individual characters
  sequence1<-unlist(strsplit(first_sequence,""))
  sequence2<-unlist(strsplit(second_sequence,""))
  
  #Creating an empty matrix
  scoring_matrix<-matrix(0,nrow=length(sequence2)+2,ncol=length(sequence1)+2)

  #Setting the gap value
  gap <- -2

  #Setting up the horizontal gap values
  for(i in 1:length(sequence1)+1){
    scoring_matrix[2,i+1]<- scoring_matrix[2,i] + gap
  }

  #Setting up the vertical gap values
  for(j in 1:length(sequence2)+1){
    scoring_matrix[j+1,2]<- scoring_matrix[j,2] + gap
  }

  #Sets the number of the last column and last row
  row_end <- length(sequence2)+2
  col_end <- length(sequence1)+2

  #Calculates the scoring matrix
  for(i in 3:row_end){
    for(j in 3:col_end){
      diagonal <- scoring_matrix[i-1,j-1] + verdict(sequence1[j-2],sequence2[i-2])
      up_score <- scoring_matrix[i-1,j] + gap
      left_score <- scoring_matrix[i,j-1] + gap
      scoring_matrix[i,j]<-max(diagonal,up_score,left_score)
    }
  }

  #Inputs the Sequence 1 and Sequence 2 into the matrix
  scoring_matrix[1, 3:(length(sequence1)+2)] <- sequence1
  scoring_matrix[3:(length(sequence2)+2),1] <- sequence2

  return(scoring_matrix)
}

scoring_matrix<-Needleman_Wunsch_Algorithmn("ATTCGAC","ATCAC")

Alignment<-function(scoring_matrix){
  
  seq1_alignmnet<-c()
  seq2_alignment<-c()
    
  j <- ncol(scoring_matrix)
  i <- nrow(scoring_matrix)

  while(i>2 && j>2){
      if(scoring_matrix[i,1]==scoring_matrix[1,j]){
  
        seq1_alignmnet <- c(scoring_matrix[1, j],seq1_alignmnet )
        seq2_alignment <- c(scoring_matrix[i, 1],seq2_alignment)
        i <- i-1
        j <- j-1
        
      }else{
        
        left_value<-scoring_matrix[i,j-1]
        up_value<-scoring_matrix[i-1,j]
        diagonal_value<-scoring_matrix[i-1,j-1]
        max_val<-max(left_value,up_value,diagonal_value)
        
        if(max_val==left_value){
          seq2_alignment <- c("-", seq2_alignment)
          seq1_alignmnet <- c(scoring_matrix[1, j], seq1_alignmnet)
          j <- j-1
        }else if(max_val==up_value){
          seq2_alignment <- c(scoring_matrix[i, 1], seq2_alignment)
          seq1_alignmnet <- c("-", seq1_alignmnet)
          i<-i-1
        }else{
          seq2_alignment <- c(scoring_matrix[1, j - 1], seq2_alignment)
          seq1_alignmnet <- c(scoring_matrix[i - 1, 1], seq1_alignmnet)
          i<-i-1
          j<-j-1
        }
      }
  }
  print(paste("Aligned Sequence 1:", paste(seq1_alignmnet, collapse = "")))
  print(paste("Aligned Sequence 2:", paste(seq2_alignment, collapse = "")))
}

scoring_matrix
Alignment(Needleman_Wunsch_Algorithmn("ATTCGAC","ATCAC"))

```

## Q3. Looking at the Metadata of an alignment (SAM) file

### Q3.1.
```{r}
single_cell_RNA_seq <- read.csv("single_cell_RNA_seq_bam.sam", nrows=73, sep="\t", header=FALSE,
fill=TRUE)
```

SN: Reference Sequence Name
LN: Reference Sequence Length

### Q3.2.
```{r}
print(paste("Length of X Chromosome:",single_cell_RNA_seq[single_cell_RNA_seq[,2]=="SN:X",3]))
```

## Q4. Looking at the Reads of an alignment (SAM) file

### Q4.1. 
```{r}
sam <- read.csv("single_cell_RNA_seq_bam.sam", sep="\t", header=FALSE,
comment.char="@", col.names = paste0("V",seq_len(30)), fill=TRUE)
sam <- sam[paste0("V",seq_len(11))]

print(paste("Number of Reads in the BAM file:", nrow(sam)))
```

### Q4.2. 
```{r}
print(sam[10,])
print("To find the chromosome to which the read was aligned, we should look at the 3rd column")
print("V11 corresponds to the the ASCII of the base quality plus 33")
```

### Q4.3.
```{r}
number_of_reads <- nrow(sam[sam[,3]=="X",])

print(paste("Number of reads in the file that align to chromosome X:",number_of_reads))
```

### Q4.4.
```{r Q4.4.}
#Isolating the Base Quality Reads of X-Chromosome
base_quality_read <- sam[sam[,3]=="X",]

#Creating a Data Frame to store the converted values
mean_bq <- data.frame("Read_Name:"=base_quality_read$V1)

#Going through each read
for (i in 1: number_of_reads){
  
  #Converting the ASCII Value into Base Quality
  bq_indiv_read <- as.numeric(charToRaw(base_quality_read[i, 11])) - 33
  
  #Adds the converted values in the dataframe
  mean_bq$Bq[i] <- I(list(bq_indiv_read))
  
  #Adds the mean base quality into the dataframe
  mean_bq$Mean_Base_Quality[i] <- mean(bq_indiv_read)
}

 print(paste("Mean of the Reads:", mean(mean_bq$Mean_Base_Quality)))
  
```

### Q4.5.
```{r}
library(ggplot2)

base_quality_read <- sam[sam[,3]=="X",]

#for(i in 1:100){
#boxplot(unlist(mean_bq$Bq[i]))
#}
mean_bq$position <-sam$V4
sam$V4
order(mean_bq$Bq[1:100])
data<-boxplot(mean_bq$Bq[1:100])

```

### Q4.6.
The column that contains the leftmost mapping position of the reads is the POS column, found in the fourth column.

### Q4.7.
```{r}
sam_9 <- sam[which(sam$V3 == 9 & sam$V4 >= 40801273 & sam$V4 <= 40805199), ]
length(sam_9$V4)
```

### Q4.8.
```{r}
#Number of reads that have mapping quality less than 50
mq_less50 <-nrow(sam[sam[5]<50,])

print(paste("Number of reads that have mapping quality of less than 50:", mq_less50 ))

```

### Q4.9.
```{r}
#Isolates the reads with mapping quality of less than 50
mapping_quality_data <- sam[sam$V5 < 50, ]

# Calculate the mean mapping quality for this subset
mean_mapping_quality <- mean(mapping_quality_data$V5)

#Prints the result
print(paste("Mean Mapping Quality of Reads:", mean_mapping_quality))
```

### Q4.10
```{r}
tdTomato_reads <- sam[sam$V3 == "tdTomato", ]
num_tdTomato_reads <- nrow(tdTomato_reads)
print(paste("Number of reads aligning to tdTomato sequence:", num_tdTomato_reads))
```
Yes, because tdTomato is a fluorophore, it would emit fluorescence under the appropriate excitation light.

Adding a fluorophore like tdTomato allows researchers to visualize and track specific cells or gene expression under a microscope.

## Q5.1: 
```{r}
vcf_con <- file("RNA_seq_annotated_variants.vcf", open="r")
vcf_file <- readLines(vcf_con)
close(vcf_con)
vcf <- data.frame(vcf_file)
header <- vcf[grepl("##", vcf$vcf_file), ]
factor(header)
variants <- read.csv("RNA_seq_annotated_variants.vcf", skip=length(header),
header=TRUE, sep="\t")
```

```{r}
print(paste("The reference allele: ", variants[1,"REF"]))
print(paste("The alternative allele: ", variants[1,"ALT"]))

```

##Q5.2
```{r}
cols_divide <- strsplit(vcf[108,1], ":")
cols_divide <- cols_divide[[1]]
cols_divide <- cols_divide[2]
col_names <- unlist(strsplit(cols_divide, "\\|"))

variants$INFO <- as.character(variants$INFO)
info <- strsplit(variants[1,8],"ANN")
info_1  <- info[[1]]
info_ann <- info_1[2]
info_sep <- unlist(strsplit(info_ann, ","))
info_ann_sep_1 <- unlist(strsplit(info_sep[1], "\\|"))
info_ann_sep_1[16] <- ""

df <- as.data.frame(t(info_ann_sep_1))
colnames(df) <- col_names

df
```

